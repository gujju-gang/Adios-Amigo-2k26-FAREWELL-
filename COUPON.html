<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>COUPON</title>
       <style>
    :root{
      --bg:#0f1724;
      --accent:#ffffff;
    }
    html,body{height:100%;margin:0;background:var(--bg);font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;color:var(--accent); -webkit-font-smoothing:antialiased;}
   .stage{
  position: relative; /* ADDED */
  min-height:100vh;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:28px;
  box-sizing:border-box;
  flex-direction:column;
  gap:18px;
}

    /* container that keeps a square area */
    .coupon-wrap{
      width:min(900px, 94vw);
      aspect-ratio: 1 / 1;
      position:relative;
      pointer-events:auto;
    }

    /* the fan area: cards anchored at the top edge so they fan vertically */
    .fan {
      position:absolute;
      left:8%;
      top:8%;
      width:84%;
      height:84%;
      pointer-events:none;
      transition: transform 520ms ease;
    }

    /* base card shared styles */
    .card {
      position:absolute;
      left:0;
      top:0;
      width:100%;
      height:100%;
      border-radius:18px;
      overflow:hidden;
      transform-origin: 50% 100%; /* pivot at bottom center so cards join at their lower edge */
      transition: transform 560ms cubic-bezier(.2,.9,.2,1), box-shadow 260ms ease, opacity 260ms ease;
      box-shadow: 0 12px 34px rgba(0,0,0,0.45);
      will-change: transform, opacity;
    }

  /* STACKED initial state — lower edges joined (vertical stack) */
.fan.stacked .card.back {
  transform-origin: 50% 100%;
  transform: translateY(0px) rotate(0deg) scale(1);
  z-index:20;
  opacity:1;
}
.fan.stacked .card.front {
  transform-origin: 50% 100%;
  /* slightly lifted so front sits just above back (joined at lower edge) */
  transform: translateY(-6px) rotate(0deg) scale(1);
  z-index:40;
  opacity:1;
}
/* (If you still have a middle card in markup, treat it like front above back:)
.fan.stacked .card.mid {
  transform-origin: 50% 100%;
  transform: translateY(-3px) rotate(0deg) scale(1);
  z-index:30;
  opacity:1;
} */

/* HOVER: tilt vertically outward — bottom card (back) rotates 67.5deg right; top (front) rotates 22.5deg right */
.coupon-wrap:hover .fan.stacked .card.back {
  transform-origin: 50% 100%;
  transform: translateY(12px) rotate(67.5deg) scale(1);
  z-index:10;
  opacity:1;
}
.coupon-wrap:hover .fan.stacked .card.front {
  transform-origin: 50% 100%;
  transform: translateY(-40px) rotate(22.5deg) scale(1);
  z-index:50;
  opacity:1;
}
/* If a middle card exists, you can use an intermediate tilt (optional):
.coupon-wrap:hover .fan.stacked .card.mid {
  transform-origin: 50% 100%;
  transform: translateY(-18px) rotate(40deg) scale(1);
  z-index:30;
  opacity:1;
} */

/* Leave .fan.fanned as a snapshot state if present, but it won't be toggled on load anymore. */
.fan.fanned .card.back {
  transform-origin: 50% 8%;
  transform: translateY(-28px) rotate(-6deg) scale(0.98);
  z-index:10;
  opacity:1;
}
.fan.fanned .card.mid {
  transform-origin: 50% 8%;
  transform: translateY(-10px) rotate(-2deg) scale(0.992);
  z-index:30;
  opacity:1;
}
.fan.fanned .card.front {
  transform-origin: 50% 8%;
  transform: translateY(14px) rotate(6deg) scale(1);
  z-index:50;
  opacity:1;
}

    /* bottom-most card (back image) — keep it image-only (no separate blur) */
   /* back card: image only — no placeholder, no shadow, no padding */
.card.back {
  z-index:20;
  background: transparent !important;
  padding: 0 !important;
  border: none !important;
  box-shadow: none !important;
}

    .card.back .inner{
      width:100%;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:12px;
      box-sizing:border-box;
    }
   /* image display: no extra margin/padding or shadows — show image clean */
/* Force coupons to portrait orientation (short side on X, long side on Y) */
.card.back img,
.card.front img {
  width:100%;
  height:100%;
  object-fit:contain;
  display:block;
  margin:0;
  padding:0;
  background:transparent;
  border-radius:0;
  box-shadow:none;
  filter:none;

  /* THIS is the fix */
  transform: rotate(90deg);
}

    /* middle card: dark mid layer with centered glowing text */
    /* middle card becomes transparent container (text optional) */
.card.mid {
  z-index:40;
  background: transparent !important;
  display:flex;
  align-items:center;
  justify-content:center;
  padding: 0 !important;
  box-shadow: none !important;
}

    .card.mid .center-text{
      pointer-events:none;
      text-align:center;
      width:86%;
    }
    .card.mid .center-text h2{
      margin:0;
      font-size:36px;
      letter-spacing:2px;
      font-weight:800;/* STACKED initial state (front visible) */
      color:#fff;
      text-transform:uppercase;
      line-height:1.02;
      text-shadow: 0 0 20px rgba(255,255,255,0.95), 0 6px 28px rgba(0,0,0,0.6);
    }

    /* top-most front card: sits on top and will overlap the text slightly */
    /* front card: image-only wrapper (no border, no bg, no shadow) */
.card.front {
  z-index:60;
  display:flex;
  align-items:center;
  justify-content:center;
  padding: 0 !important;
  border-radius: 0 !important;
  background: transparent !important;
  border: none !important;
  box-shadow: none !important;
}

   
   /* subtle hover lift — keep only shadow so tilt rules control transforms */
.coupon-wrap:focus-within .card.front,
.coupon-wrap:hover .card.front { box-shadow: 0 36px 88px rgba(0,0,0,0.75); }

    /* reveal animation */
    .coupon-wrap { opacity:0; transform: scale(0.98); transition: opacity 420ms ease, transform 420ms cubic-bezier(.2,.9,.2,1); }
    .coupon-wrap.visible { opacity:1; transform: scale(1); }

    /* arc title */
    .arc-container { position:relative; width:100%; max-width:980px; pointer-events:none; z-index:160; display:flex; justify-content:center; margin-bottom:4px; }
    .arc-svg { width:100%; height:140px; overflow:visible; display:block; }
    .arc-text { fill:#fff; font-weight:900; font-size:48px; letter-spacing:2px; text-anchor:middle; dominant-baseline:middle; }

    /* entry small form below the coupon */
    .entry-form {
      width:100%;
      max-width:760px;
      display:flex;
      gap:12px;
      justify-content:center;
      align-items:center;
      padding:12px 6px 0 6px;
      box-sizing:border-box;
      z-index:120;
    }

    /* questionnaire modal (unchanged) */
    #questionnaire {
      position:fixed;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%) scale(0.98);
      width:min(520px, 94vw);
      height:auto;
      max-height:86vh;
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));
      border-radius:18px;
      padding:20px;
      box-sizing:border-box;
      box-shadow: 0 30px 80px rgba(0,0,0,0.6);
      backdrop-filter: blur(8px);
      z-index:20000;
      opacity:0;
      pointer-events:none;
      overflow:auto;
      transition: opacity 320ms ease, transform 320ms cubic-bezier(.2,.9,.2,1);
    }
    #questionnaire.visible {
      opacity:1;
      transform:translate(-50%,-50%) scale(1);
      pointer-events:auto;
    }
    #questionnaire h3 { margin:4px 0 14px 0; font-size:20px; text-align:center; }
    #questionnaire .q-row { display:flex; gap:10px; margin-bottom:10px; }
    #questionnaire input {
      width:100%;
      padding:10px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.02);
      color:#fff;
      outline:none;
      box-sizing:border-box;
    }
    #questionnaire .q-actions { display:flex; gap:10px; justify-content:flex-end; margin-top:8px; }
    #questionnaire button {
      padding:10px 14px;
      border-radius:8px;
      border:none;
      background:rgba(255,255,255,0.08);
      color:#fff;
      cursor:pointer;
      font-weight:700;
    }

    @media (max-width:720px){
      .arc-svg { height:100px; }
      .arc-text { font-size:26px; }
      .entry-form { flex-direction:column; gap:8px; padding:6px; }
      .entry-form input { width:92%; }
      #questionnaire { width:92vw; padding:14px; }
    }
  /* Coupon boundary square + moving-text train */
.coupon-boundary {
  position:absolute;
  left:50%;
  bottom:6%;
  width:78%;
  height:78%;
  transform: translateX(-50%);
  border-radius: 10px;
  z-index:15; /* behind coupons (cards z-index >=20) */
  pointer-events:none;
  overflow:visible; /* allow ticks to travel along edge */
  box-sizing:border-box;
}

/* visible thick border (the "track") — increased corner radius for smooth bends */
.coupon-border-visual {
  position:absolute;
  inset:0;
  border: 24px solid rgba(255,255,255,0.95);
  /* BIGGER radius so the train bends nicely around corners */
  border-radius: 60px;
  z-index:16;
  pointer-events:none;
  box-sizing:border-box;
}

/* ticker container that holds the moving text 'cars' */
.ticker-wrap {
  position:absolute;
  inset:0; /* fill boundary */
  z-index:17; /* still behind coupons but above the visual border */
  pointer-events:none;
  overflow:visible;
}

/* each moving text item (a "car" on the train) */
.tick {
  position:absolute; /* left/top set by JS */
  top:0;
  left:0;
  white-space:nowrap;
  font-weight:900;
  font-size:16px;      /* slightly larger so it's readable inside thick border */
  letter-spacing:1px;
  color:#000000;       /* BLACK font as requested */
  text-transform:uppercase;
  pointer-events:none;
  transform: translate(-50%, -50%); /* center the label on its coordinate */
  text-shadow: 0 1px 4px rgba(255,255,255,0.25); /* small halo so black text reads on dark BG */
  line-height:1;
}

/* responsive text sizing */
@media (max-width:720px){
  .tick { font-size:12px; }
}
 /* --- iOS glass card (ENTER GET YOUR TICKET--) --- */
.ios-card {
  position: relative;
  width: min(860px, 92%);
  max-width:760px;
  margin: 8px auto 0;
  z-index: 30; /* above the coupon cards so it's clearly visible */
  pointer-events: auto;
  box-sizing: border-box;
}

/* inner panel - frosted, translucent */
.ios-card-inner{
  width:100%;
  border-radius:14px;
  padding:14px;
  box-sizing:border-box;
  background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
  border: 1px solid rgba(255,255,255,0.12);
  backdrop-filter: blur(12px) saturate(130%);
  -webkit-backdrop-filter: blur(12px) saturate(130%);
  box-shadow: 0 10px 30px rgba(3,6,12,0.6);
  display:flex;
  flex-direction:column;
  gap:10px;
  align-items:center;
  justify-content:center;
}

/* header text */
.ios-head { width:100%; display:flex; justify-content:center; }
.ios-title {
  font-weight:800;
  font-size:18px;
  color: #ffffff;
  letter-spacing:1px;
  text-transform:uppercase;
  text-align:center;
  padding:4px 8px;
  backdrop-filter: none;
}

/* form rows */
.ios-form { width:100%; display:flex; flex-direction:column; gap:8px; align-items:center; }
.ios-row { width:100%; display:flex; justify-content:center; }
.ios-row input {
  width: 92%;
  max-width:640px;
  padding:10px 12px;
  border-radius:10px;
  border: 1px solid rgba(255,255,255,0.10);
  background: rgba(255,255,255,0.02);
  color: #fff;
  outline:none;
  box-sizing:border-box;
  font-size:15px;
}

/* subtle inner glow for focus */
.ios-row input:focus {
  border-color: rgba(255,255,255,0.22);
  box-shadow: 0 6px 20px rgba(80,120,255,0.06);
}

/* actions */
.ios-actions { width:100%; display:flex; justify-content:center; margin-top:6px; }
.ios-submit {
  padding:10px 18px;
  border-radius:10px;
  border:none;
  cursor:pointer;
  font-weight:800;
  background: linear-gradient(180deg,#ffffff,#e8eefc);
  color:#0b1220;
  box-shadow: 0 8px 24px rgba(9,14,24,0.2);
}

/* small screens */
@media (max-width:720px){
  .ios-card-inner { padding:12px; }
  .ios-title { font-size:14px; }
  .ios-row input { width:94%; font-size:14px; padding:10px; }
  .ios-submit { padding:10px 14px; font-size:14px; }
}
</style>


</head>
<body>
      <div class="stage">
    <!-- ARC TITLE (text follows a gentle arc path) -->
    <div class="arc-container" aria-hidden="true">
      <svg class="arc-svg" viewBox="0 0 1000 160" preserveAspectRatio="xMidYMid meet" role="img" aria-label="Get your entry ticket">
        <defs>
          <!-- gentle upward arc path -->
          <path id="arcPath" d="M40,118 C240,-10 760,-10 960,118" />
        </defs>
        <text class="arc-text" aria-hidden="true">
          <textPath href="#arcPath" startOffset="50%" text-anchor="middle" dominant-baseline="middle">
            GET YOUR ENTRY TICKET TO THE SHOW NOW!!!
          </textPath>
        </text>
      </svg>
    </div>

    <div class="coupon-wrap" id="couponWrap" tabindex="0" aria-label="Coupon preview">

  <!-- Square boundary frame -->
    <!-- BOUNDARY: moving-text "train" that runs along the border -->
  <div class="coupon-boundary" aria-hidden="true">
    <!-- visual square border (kept for appearance) -->
    <div class="coupon-border-visual" aria-hidden="true"></div>

    <!-- moving text elements (multiple cars) -->
    <div class="ticker-wrap" aria-hidden="true" role="presentation">
      <span class="tick">ENTRY TICKET!!</span>
      <span class="tick">ENTRY TICKET!!</span>
      <span class="tick">ENTRY TICKET!!</span>
      <span class="tick">ENTRY TICKET!!</span>
      <span class="tick">ENTRY TICKET!!</span>
    </div>
  </div>


  <!-- Fan area: stacked vertically at start -->
  <div class="fan stacked" id="fanArea" aria-hidden="false">
      <!-- 1) Back image card (image-only, no blur) -->
        <div class="card back" role="img" aria-label="Coupon back">
          <div class="inner">
            <img src="Assets/images/coupon-back.jpg" alt="Back of coupon with QR code">
          </div>
        </div>

        <!-- 3) Top-most front card: front image -->
        <div class="card front" role="img" aria-label="Coupon front">
          <img src="Assets/images/coupon-front.jpg" alt="Coupon front artwork">
        </div>
      </div>
    </div>
  <!-- iOS-style glass info card (ENTER GET YOUR TICKET--) -->
  <div class="ios-card" role="region" aria-label="Get ticket" aria-hidden="false">
    <div class="ios-card-inner">
      <div class="ios-head">
        <span class="ios-title">ENTER GET YOUR TICKET--</span>
      </div>

      <form id="ios-form" class="ios-form" autocomplete="off" novalidate>
        <div class="ios-row">
          <input id="ios-name" name="name" type="text" placeholder="Full name" required />
        </div>
        <div class="ios-row">
          <input id="ios-email" name="email" type="email" placeholder="Gmail address" required />
        </div>

        <div class="ios-actions">
          <button type="submit" class="ios-submit">Get Ticket</button>
        </div>
      </form>
    </div>
  </div>

    <!-- QUESTIONNAIRE square (hidden until user scrolls past coupon) -->
    <div id="questionnaire" role="dialog" aria-hidden="true">
      <h3>Quick Questionnaire</h3>
      <form id="questionnaire-form" autocomplete="off">
        <div class="q-row"><input type="text" id="q-name" name="qName" placeholder="Full name" required></div>
        <div class="q-row"><input type="email" id="q-email" name="qEmail" placeholder="Gmail address" required></div>
        <div class="q-actions">
          <button type="button" id="q-cancel">Cancel</button>
          <button type="submit" id="q-submit">Submit</button>
        </div>
      </form>
    </div>
  </div>
  
  <script>
  // reveal the coupon area on load — keep stacked, DO NOT auto-fan
window.addEventListener('load', () => {
  const wrap = document.getElementById('couponWrap');
  const fan = document.getElementById('fanArea');

  // reveal coupon visual
  requestAnimationFrame(()=> setTimeout(()=> wrap.classList.add('visible'), 50));

  // force the stacked state and ensure fanned is removed (defensive)
  if (fan) {
    fan.classList.add('stacked');
    fan.classList.remove('fanned');
  }
});

    // keyboard interaction: Enter opens front image to save/print
    const wrapEl = document.getElementById('couponWrap');
    if (wrapEl) {
      wrapEl.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          window.open('./image%20(1).jpg', '_blank');
        }
      });
    }

      // iOS form -> SheetMonkey endpoint (paste your endpoint into SHEETMONKEY_URL)
    const iosForm = document.getElementById('ios-form');
    if (iosForm) {
      iosForm.addEventListener('submit', async (ev) => {
        ev.preventDefault();
        const name = document.getElementById('ios-name').value.trim();
        const email = document.getElementById('ios-email').value.trim();
        const inner = iosForm.querySelector('.ios-card-inner');

        // simple validation
        if (!name || !email) {
          inner.style.transform = 'translateY(-4px)';
          setTimeout(()=> inner.style.transform = '', 180);
          return;
        }

        const btn = iosForm.querySelector('.ios-submit');
        const originalText = btn.textContent;
        btn.disabled = true;
        btn.textContent = 'Sending...';

        // <<< PUT YOUR SheetMonkey endpoint URL HERE >>>
        const SHEETMONKEY_URL = 'https://api.sheetmonkey.io/form/dY6TgAd2143fsZ66Tqx8VE';

        try {
          const res = await fetch(SHEETMONKEY_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name, email })
          });

          if (res.ok) {
            btn.textContent = 'Saved';
            // optional: clear fields
            // document.getElementById('ios-name').value = '';
            // document.getElementById('ios-email').value = '';
          } else {
            btn.textContent = 'Error';
            console.error('SheetMonkey error', await res.text());
          }
        } catch (err) {
          console.error('Network error', err);
          btn.textContent = 'Offline';
        } finally {
          setTimeout(()=> { btn.disabled = false; btn.textContent = originalText; }, 1100);
        }
      });
    }

    // QUESTIONNAIRE behavior: show when user reaches bottom of page, hide on cancel
    const questionnaire = document.getElementById('questionnaire');
    let questionnaireShown = false;
    function showQuestionnaire() {
      if (!questionnaire || questionnaireShown) return;
      questionnaire.classList.add('visible');
      questionnaire.setAttribute('aria-hidden','false');
      questionnaireShown = true;
    }
    function hideQuestionnaire() {
      if (!questionnaire) return;
      questionnaire.classList.remove('visible');
      questionnaire.setAttribute('aria-hidden','true');
    }

   // show questionnaire once the user has scrolled past the coupon area (so cards are out of view)
function checkScrollPastCoupon() {
  const wrap = document.getElementById('couponWrap');
  if (!wrap) return;
  // distance from top of document
  const wrapBottom = wrap.offsetTop + wrap.offsetHeight;
  // if page vertical scroll position has passed the coupon bottom, reveal questionnaire
  if (window.scrollY > (wrapBottom - 40)) {
    showQuestionnaire();
    // remove listener after first trigger
    window.removeEventListener('scroll', checkScrollPastCoupon, { passive: true });
  }
}
window.addEventListener('scroll', checkScrollPastCoupon, { passive: true });
// also check once on load (in case user loaded mid-page)
setTimeout(checkScrollPastCoupon, 500);

    // questionnaire cancel + submit handlers
    const qCancel = document.getElementById('q-cancel');
    if (qCancel) qCancel.addEventListener('click', hideQuestionnaire);

    const qForm = document.getElementById('questionnaire-form');
    if (qForm) {
      qForm.addEventListener('submit', (ev) => {
        ev.preventDefault();
        const data = {
          name: document.getElementById('q-name').value.trim(),
          email: document.getElementById('q-email').value.trim(),
          phone: document.getElementById('q-phone').value.trim(),
          note: document.getElementById('q-note').value.trim()
        };
        // For now, just log. Later we can wire this to Google Sheets, Firebase, or a simple server endpoint.
        console.log('Questionnaire submission:', data);
        // feedback
        document.getElementById('q-submit').textContent = 'Sent';
        setTimeout(()=> { document.getElementById('q-submit').textContent = 'Submit'; hideQuestionnaire(); }, 900);
      });
    }
   </script>

  <script>
  // Moving-text train that runs ON the rounded border centerline and smoothly bends through corners
  (function () {
    const container = document.querySelector('.coupon-boundary');
    if (!container) return;
    const ticks = Array.from(container.querySelectorAll('.tick'));
    if (!ticks.length) return;

    // CONFIG (keep these in sync with CSS)
    const cycleSeconds = 10;          // time for one full loop
    const spacing = 1 / ticks.length; // even spacing
    const BORDER_WIDTH = 24;          // must match .coupon-border-visual border width (px)
    const CSS_BORDER_RADIUS = 60;     // must match .coupon-border-visual border-radius (px)

    // Derived geometry (updated on resize)
    let W = 0, H = 0, perim = 0, r = 0, inset = 0;
    function recalc() {
      const rect = container.getBoundingClientRect();
      W = Math.max(2, rect.width);
      H = Math.max(2, rect.height);

      // centerline path is placed at half the border stroke from outer edge
      inset = BORDER_WIDTH * 0.5;

      // effective corner radius along the centerline
      r = Math.max(0, CSS_BORDER_RADIUS - inset);

      // lengths of straight segments between rounded corners
      const straightW = Math.max(0, W - 2 * (inset + r));
      const straightH = Math.max(0, H - 2 * (inset + r));

      const arcLen = (Math.PI / 2) * r; // quarter-circle arc length
      perim = 2 * (straightW + straightH) + 4 * arcLen;

      // store for convenience
      recalc.straightW = straightW;
      recalc.straightH = straightH;
      recalc.arcLen = arcLen;
    }
    recalc();
    window.addEventListener('resize', () => { recalc(); });

    // Return point on rounded-rect centerline for normalized t in [0,1)
    // Path goes clockwise starting at top-left straight start (just right of top-left corner)
    function pointAt(t) {
      t = ((t % 1) + 1) % 1;
      const dist = t * perim;
      const straightW = recalc.straightW;
      const straightH = recalc.straightH;
      const arcLen = recalc.arcLen;

      // helper values: centers of corner arcs
      const cxTL = inset + r;
      const cyTL = inset + r;
      const cxTR = inset + r + straightW;
      const cyTR = inset + r;
      const cxBR = inset + r + straightW;
      const cyBR = inset + r + straightH;
      const cxBL = inset + r;
      const cyBL = inset + r + straightH;

      // segment 1: top straight (left -> right)
      if (dist <= straightW) {
        const x = inset + r + dist;
        const y = inset;
        const dx = 1; const dy = 0;
        return { x, y, tx: dx, ty: dy, edgeIndex:0 };
      }
      let d = dist - straightW;

      // segment 2: top-right corner (quarter arc, angle -90deg -> 0deg)
      if (d <= arcLen) {
        const ang = -Math.PI/2 + (d / arcLen) * (Math.PI/2);
        const x = cxTR + Math.cos(ang) * r;
        const y = cyTR + Math.sin(ang) * r;
        // tangent along arc: derivative = (-sin, cos)
        const tx = -Math.sin(ang);
        const ty = Math.cos(ang);
        return { x, y, tx, ty, edgeIndex:1 };
      }
      d -= arcLen;

      // segment 3: right straight (top -> bottom)
      if (d <= straightH) {
        const x = inset + r + straightW;
        const y = inset + r + d;
        const dx = 0; const dy = 1;
        return { x, y, tx: dx, ty: dy, edgeIndex:2 };
      }
      d -= straightH;

      // segment 4: bottom-right corner (0deg -> 90deg)
      if (d <= arcLen) {
        const ang = 0 + (d / arcLen) * (Math.PI/2);
        const x = cxBR + Math.cos(ang) * r;
        const y = cyBR + Math.sin(ang) * r;
        const tx = -Math.sin(ang);
        const ty = Math.cos(ang);
        return { x, y, tx, ty, edgeIndex:3 };
      }
      d -= arcLen;

      // segment 5: bottom straight (right -> left)
      if (d <= straightW) {
        const x = inset + r + (straightW - d);
        const y = inset + r + straightH;
        const dx = -1; const dy = 0;
        return { x, y, tx: dx, ty: dy, edgeIndex:4 };
      }
      d -= straightW;

      // segment 6: bottom-left corner (90deg -> 180deg)
      if (d <= arcLen) {
        const ang = Math.PI/2 + (d / arcLen) * (Math.PI/2);
        const x = cxBL + Math.cos(ang) * r;
        const y = cyBL + Math.sin(ang) * r;
        const tx = -Math.sin(ang);
        const ty = Math.cos(ang);
        return { x, y, tx, ty, edgeIndex:5 };
      }
      d -= arcLen;

      // segment 7: left straight (bottom -> top)
      if (d <= straightH) {
        const x = inset;
        const y = inset + r + (straightH - d);
        const dx = 0; const dy = -1;
        return { x, y, tx: dx, ty: dy, edgeIndex:6 };
      }
      d -= straightH;

      // segment 8: top-left corner (180deg -> 270deg)
      // remaining d <= arcLen
      const ang = Math.PI + (d / arcLen) * (Math.PI/2);
      const x = cxTL + Math.cos(ang) * r;
      const y = cyTL + Math.sin(ang) * r;
      const tx = -Math.sin(ang);
      const ty = Math.cos(ang);
      return { x, y, tx, ty, edgeIndex:7 };
    }

    // animation loop
    let start = null;
    function frame(now) {
      if (!start) start = now;
      const elapsed = (now - start) / 1000;
      const base = (elapsed % cycleSeconds) / cycleSeconds;

      ticks.forEach((el, i) => {
        const phase = (i * spacing) % 1;
        const t = (base + phase) % 1;
        const p = pointAt(t);

        // position (absolute pixels relative to container)
        el.style.left = p.x + 'px';
        el.style.top = p.y + 'px';

        // compute tangent angle in degrees
        let ang = Math.atan2(p.ty, p.tx) * 180 / Math.PI;

        // keep text upright: if angle points left-ish, flip 180deg so text reads correctly
        if (ang > 90 || ang < -90) ang += 180;

        // center and rotate label to match path tangent
        el.style.transform = `translate(-50%,-50%) rotate(${ang}deg)`;
      });

      requestAnimationFrame(frame);
    }

    // initialize
    (function initPositions() {
      const rect = container.getBoundingClientRect();
      if (rect.width < 40 || rect.height < 40) {
        setTimeout(() => { recalc(); initPositions(); }, 120);
        return;
      }
      recalc();
      ticks.forEach((el) => { el.style.opacity = '1'; });
      requestAnimationFrame(frame);
    })();

  })();
</script>
</body>
</html>



